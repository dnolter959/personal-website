---
title: "SQL Tutorial"
format: html
---

**Note:** *ChatGPT (and others) are good at writing SQL queries if you prompt them well. Even so, if you use SQL, it's important to know how where it comes from and how it works. I try to cover that here.*    

## Background

SQL is a language that is used to query and manipulate data stored in relational databases. A relational database is just a set of tables that are related and share key information between them, allowing us to link them together to answer the questions we want to answer about the underlying data. It's useful to think of these tables as excel spreadsheets, except they can be very large, they can be continuously updated, and you can extract highly specific information from them using code instead of filtering and formulas.

Before databases, we used to store information in physical media like file folders; this works until it doesn't...if you have a lot of data it becomes a nightmare to modify it, update it, keep backups, and access it. Hence, SQL.

SQL is important because data is important. If you are starting a company, for example, you need to keep track of your customers and their information, as well as other data pertaining to, say, your operations and employees. Once we store data in databases, we need to manage and access it efficiently, and so we developed the relational model and SQL. 

Storing data in tables is easy for us to understand and that we typically do so seems like a foregone conclusion, but it is not clearly the best or only way to do so. You can also store data in tree structures or network structures, and some data is still stored this way because its underlying nature is better captured in this way, or it is much more efficient to store it this way. 

So-called NoSQL databases (e.g., MongoDB) also exist. NoSQL databases might replace clearly defined data tables with more flexibly defined, schema-less "collections" of records. The decision to use a NoSQL database vs. a relational data often has to do with data storage and performance considerations. I might tackle this in another post. But for now, onwards to SQL.     

## Terminology

Primary key
: One or more columns that can be used as the unique identifier for each row in a table

Foreign key
: One or more columns that can be used to identify a single row in another table. A table has a foreign key if it contains a column (or set of columns) with values that may be duplicated, but these values uniquely identify a row in another table.  

Result set
: A nonpersistent table, normally the result of a SQL query

## Examples

The best way to learn SQL is by working through many examples which increase incrementally in difficulty. I'll do that below, adding comments and "gotchas" along the way as appropriate. 

For most examples, I use the [Sakila sample database](https://dev.mysql.com/doc/sakila/en/sakila-structure.html).  It is a built-in database in MySQL which includes data that would be relevant to a DVD rental store.

```{r, echo=FALSE}
library(DBI)
library(RMySQL)
con <- dbConnect(RMySQL::MySQL(), 
             dbname = "sakila", 
             host = "localhost", 
             port = 3306,
             user = "root",
             password = "")

```

### I. Creating and modifying tables

#### 1. Create a table

```{sql}
#| connection = con
DROP TABLE IF EXISTS classes, student;
```

```{sql}
#| connection = con
CREATE TABLE student (
  student_id SMALLINT UNSIGNED,
  first_name VARCHAR(20),
  last_name VARCHAR(20),
  CONSTRAINT pk_student_id PRIMARY KEY (student_id)
);
```

```{sql}
#| connection = con
DESC student;
```

- Here is one table called `student`. It has a primary key called `student_id`. 
- I first delete the tables if they exist already or else I can't create them on subsequent reruns of this code.  
- Note that I must define the variable type for each variable, and I assign student_id to be the `primary_key`


```{sql}
#| connection = con
CREATE TABLE classes (
  student_id SMALLINT UNSIGNED AUTO_INCREMENT,
  class VARCHAR(20),
  CONSTRAINT pk_student_class PRIMARY KEY (student_id, class),
  CONSTRAINT fk_student_id FOREIGN KEY (student_id) REFERENCES student (student_id)
);
```

```{sql}
#| connection = con
DESC classes;
```

- Here is another table called `classes`. It has a primary key that is the combination of two columns: `student_id` and class. Each student can have more than one `class` associated with them; but `student_id`-`class` combination is unique. This is a valid form a primary key (it's called a compound key). 
- I also add a constraint that the foreign key in this table is student_id. This is because while it may be repeated in this table; it uniquely identifies a row of the student table (its "parent" table). An implication of this constraint is that I cannot add a row to this table with a student_id that is not already in the student table. 
- Note that `first_name` and `last_name` are not repeated here. While it might be useful to see those fields in the classes table but you should not add them here; As this information is already available in the `student` table, adding them here would be a redundancy and very much against the spirit of relational databases.    

#### 2. Alter table

```{sql}
#| connection = con
ALTER TABLE classes DROP FOREIGN KEY fk_student_id;
```

```{sql}
#| connection = con
ALTER TABLE student MODIFY student_id SMALLINT UNSIGNED AUTO_INCREMENT;
```

```{sql}
#| connection = con
ALTER TABLE classes ADD CONSTRAINT fk_student_id FOREIGN KEY (student_id) REFERENCES student(student_id);
```

```{sql}
#| connection = con
DESC student;
```

- You can alter tables as above. For example, I first removed the foreign key in the classes table, and then added an auto_increment to the student table, and then I added back the foreign key constraint in the classes table 

#### 3. Populate table with data

```{sql}
#| connection = con
INSERT INTO student (student_id, first_name, last_name)
VALUES 
  (null, "Don", "Joe"),
  (null, "Sam", "Jam");
```

```{sql}
#| connection = con
SELECT * FROM student;
```

```{sql}
#| connection = con
INSERT INTO classes (student_id, class)
VALUES 
  (1, "Math"),
  (2, "Math"),
  (2, "Gym");
```

```{sql}
#| connection = con
SELECT * FROM classes;
```

#### 4. Update data

```{sql}
#| connection = con
UPDATE student 
SET last_name = "Cow"
WHERE student_id = 1;
```

```{sql}
#| connection = con
SELECT * FROM student;
```

#### 5. Delete data

```{sql}
#| connection = con
DELETE FROM classes 
WHERE student_id = 1;
```

```{sql}
#| connection = con
SELECT * FROM classes;
```

### II. Simple queries

#### 1. Output all data, limit records

```{sql}
#| connection = con
SELECT * FROM actor LIMIT 3;
```

#### 2. Output some columns, limit records

```{sql}
#| connection = con
SELECT actor_id, first_name FROM actor LIMIT 3;
```

#### 3. Output some columns and rows

```{sql}
#| connection = con
SELECT actor_id, first_name FROM actor WHERE actor_id = 2;
```

#### 4. Special select

```{sql}
#| connection = con
SELECT 
  'COMMON' AS lang,
  language_id*23 AS lang_mult,
  UPPER(name) AS lang_name
FROM language;
```



### III. Less simple queries

